name: Sync Repeaters from MeshMapper API

on:  
  schedule:    
    # Runs every hour at minute 0
    - cron: '0 * * * *'
  workflow_dispatch:    # Allows manual triggering

permissions:
  contents: write
  pull-requests: write

jobs:    
  sync-repeaters:     
    runs-on: ubuntu-latest
    steps:  
      - name: Checkout repository
        uses: actions/checkout@v4
        with:  
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:   
          python-version: '3.x'

      - name: Install dependencies
        run: pip install pyyaml requests urllib3

      - name: Fetch and sync repeaters
        id: sync
        run: |
          python << 'EOF'
          import yaml
          import requests
          import json
          import os
          import time
          from urllib.parse import quote
          from datetime import datetime

          # Define valid state values with proper capitalization
          VALID_STATES = {
              'duplicate':  'Duplicate',
              'new': 'New',
              'active': 'Active',
              'observer': 'Observer',
              'backbonereserved': 'BackboneReserved',
              'reserved': 'Reserved'
          }

          def normalize_state(state):
              """Normalize state to proper capitalization"""
              if not state:
                  return None
              state_lower = str(state).lower()
              return VALID_STATES.get(state_lower, state.capitalize())

          def get_city_name(lat, lon):
              """Get city/town name from coordinates using Nominatim"""
              if not lat or not lon:
                  return None
              try:
                  # Nominatim requires a user-agent
                  headers = {'User-Agent': 'MeshCore-GOME-Sync/1.0 (https://github.com/MrAlders0n/MeshCore-GOME)'}
                  url = f"https://nominatim.openstreetmap.org/reverse?format=json&lat={lat}&lon={lon}&zoom=10"
                  response = requests.get(url, headers=headers, timeout=10)
                  response.raise_for_status()
                  data = response.json()
                  address = data.get('address', {})
                  # Try different city fields in order of specificity
                  return address.get('city') or address.get('town') or address.get('village') or address.get('municipality') or address.get('suburb')
              except Exception as e:
                  print(f"  Error geocoding {lat}, {lon}: {e}")
                  return None

          # Fetch repeaters from API
          api_url = 'https://yow.meshmapper.net/repeaters.json'
          print(f"Fetching repeaters from {api_url}...")
          response = requests.get(api_url)
          response.raise_for_status()
          api_repeaters = response.json()
          print(f"Found {len(api_repeaters)} repeaters in API")

          # Load existing YAML file
          yml_path = 'docs/deployment/data/repeaters.yml'
          with open(yml_path, 'r') as f:
              existing_data = yaml.safe_load(f)

          # Track corrections and updates
          state_corrections = []
          last_heard_updates = 0
          power_updates = 0
          location_updates = 0

          # Normalize all existing states first
          for r in existing_data.get('repeaters', []):
              if 'state' in r:
                  old_state = r['state']
                  new_state = normalize_state(old_state)
                  if old_state != new_state: 
                      state_corrections.append({
                          'name': r.get('name', 'Unknown'),
                          'id': r.get('id', ''),
                          'old_state': old_state,
                          'new_state': new_state
                      })
                      r['state'] = new_state
                      print(f"  Corrected state:  {r.get('name')} - '{old_state}' ‚Üí '{new_state}'")

          # Create maps for quick lookup
          existing_hex_id_map = {str(r.get('hex_id', '')).upper(): r for r in existing_data.get('repeaters', []) if r.get('hex_id')}
          existing_ids = {str(r.get('id', '')).upper() for r in existing_data.get('repeaters', []) if r.get('id')}
          existing_id_map = {str(r.get('id', '')).upper(): r for r in existing_data.get('repeaters', []) if r.get('id')}

          # Track changes
          new_repeaters = []
          duplicate_repeaters = []
          updated_repeaters = []
          
          for repeater in api_repeaters:    
              hex_id = repeater.get('hex_id')
              repeater_id = repeater.get('id')
              api_name = repeater.get('name', 'Unknown')
              api_power = repeater.get('power')
              api_lat = repeater.get('lat')
              api_lon = repeater.get('lon')
              
              if not hex_id: continue
              
              hex_id_upper = str(hex_id).upper()
              repeater_id_upper = str(repeater_id).upper() if repeater_id else ''
              
              if hex_id_upper in existing_hex_id_map:  
                  existing_repeater = existing_hex_id_map[hex_id_upper]
                  existing_name = existing_repeater.get('name', '')
                  
                  # Update last_heard
                  last_heard = repeater.get('last_heard')
                  if last_heard and existing_repeater.get('last_heard') != last_heard:
                      existing_repeater['last_heard'] = last_heard
                      last_heard_updates += 1
                  
                  # Update power
                  if api_power and existing_repeater.get('power_watt') != api_power:
                      existing_repeater['power_watt'] = api_power
                      power_updates += 1
                      print(f"  Updated power for {existing_name}: {api_power}")

                  # Update location if TBD or null
                  current_loc = str(existing_repeater.get('location', '') or '')
                  if api_lat and api_lon and (not current_loc or 'TBD' in current_loc):
                      city = get_city_name(api_lat, api_lon)
                      if city:
                          existing_repeater['location'] = city
                          location_updates += 1
                          print(f"  Updated location for {existing_name}: {city}")
                          time.sleep(1) # Rate limit

                  if existing_name != api_name:   
                      old_name = existing_name
                      existing_repeater['name'] = api_name
                      encoded_name = quote(api_name)
                      existing_repeater['contact'] = f"meshcore://contact/add?name={encoded_name}&public_key={hex_id_upper}&type=2"
                      updated_repeaters.append({'hex_id': hex_id_upper, 'old_name': old_name, 'new_name': api_name, 'id': existing_repeater.get('id', '')})
                  continue
              
              # New Repeater logic
              is_duplicate = repeater_id_upper in existing_ids
              state = "Duplicate" if is_duplicate else "New"
              location = 'TBD'
              if api_lat and api_lon:
                  city = get_city_name(api_lat, api_lon)
                  if city:
                      location = city
                      time.sleep(1)

              new_entry = {
                  'id': repeater_id_upper,
                  'name': api_name,
                  'antenna': 'TBD',
                  'location': location,
                  'contact': f"meshcore://contact/add?name={quote(api_name)}&public_key={hex_id_upper}&type=2",
                  'state': state,
                  'hex_id': hex_id_upper,
                  'last_heard': repeater.get('last_heard'),
                  'power_watt': api_power
              }
              
              if is_duplicate:
                  new_entry['existing_name'] = existing_id_map.get(repeater_id_upper, {}).get('name', 'Unknown')
                  duplicate_repeaters.append(new_entry)
              else:
                  new_repeaters.append(new_entry)

          has_changes = (new_repeaters or duplicate_repeaters or updated_repeaters or state_corrections or last_heard_updates or power_updates or location_updates)
          
          if has_changes:  
              existing_data['repeaters'].extend(new_repeaters + duplicate_repeaters)
              
              with open(yml_path, 'w') as f:
                  f.write("repeaters:\n")
                  for repeater in existing_data['repeaters']: 
                      f.write(f'  - id: "{repeater.get("id", "")}"\n')
                      f.write(f'    name: "{repeater.get("name", "")}"\n')
                      f.write(f'    antenna: "{repeater.get("antenna", "TBD")}"\n')
                      f.write(f'    location: "{repeater.get("location", "TBD")}"\n')
                      
                      # Fix for null quoting: write literal null if value is missing or "null" string
                      for field in ['contact', 'state', 'hex_id', 'power_watt']:
                          val = repeater.get(field)
                          if val and str(val).lower() != "null":
                              f.write(f'    {field}: "{val}"\n')
                          else:
                              f.write(f'    {field}: null\n')
                      
                      lh = repeater.get('last_heard')
                      f.write(f'    last_heard: {lh if lh and str(lh).lower() != "null" else "null"}\n\n')
              
              # GITHUB_OUTPUT logic
              output_file = os.environ.get('GITHUB_OUTPUT')
              if output_file:
                  with open(output_file, 'a') as f:
                      f.write(f"new_count={len(new_repeaters)}\n")
                      f.write(f"duplicate_count={len(duplicate_repeaters)}\n")
                      f.write(f"updated_count={len(updated_repeaters)}\n")
                      f.write(f"state_corrections_count={len(state_corrections)}\n")
                      f.write(f"last_heard_updates={last_heard_updates}\n")
                      f.write(f"power_updates={power_updates}\n")
                      f.write(f"location_updates={location_updates}\n")
                      f.write(f"has_duplicates={'true' if duplicate_repeaters else 'false'}\n")
                      f.write("has_changes=true\n")
                      
                      # Tables
                      def make_table(rows): return "\n".join(rows) if rows else ""
                      new_table = [f"| üÜï | {r['name'].replace('|', '\\|')} | `{r['id']}` | `{r['hex_id'][:16]}...` |" for r in new_repeaters]
                      f.write(f"new_table<<EOF\n{make_table(new_table)}\nEOF\n")
                      
                      dup_table = [f"| ‚ö†Ô∏è | {r.get('existing_name', '').replace('|', '\\|')} | {r['name'].replace('|', '\\|')} | `{r['id']}` | `{r['hex_id'][:16]}...` |" for r in duplicate_repeaters]
                      f.write(f"dup_table<<EOF\n{make_table(dup_table)}\nEOF\n")
                      
                      upd_table = [f"| `{r['id']}` | {r['old_name'].replace('|', '\\|')} | {r['new_name'].replace('|', '\\|')} | `{r['hex_id'][:16]}...` |" for r in updated_repeaters]
                      f.write(f"upd_table<<EOF\n{make_table(upd_table)}\nEOF\n")
                      
                      state_table = [f"| {r['name'].replace('|', '\\|')} | `{r['id']}` | `{r['old_state']}` | `{r['new_state']}` |" for r in state_corrections]
                      f.write(f"state_table<<EOF\n{make_table(state_table)}\nEOF\n")
          else:
              with open(os.environ.get('GITHUB_OUTPUT'), 'a') as f: f.write("has_changes=false\n")
          EOF

      - name: Create Pull Request
        if: steps.sync.outputs.has_changes == 'true'
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:  
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Sync repeaters from MeshMapper API (${{ steps.sync.outputs.new_count }} new, ${{ steps.sync.outputs.power_updates }} power updates)"
          title: "üîÑ Sync: ${{ steps.sync.outputs.new_count }} new, ${{ steps.sync.outputs.power_updates }} power, ${{ steps.sync.outputs.location_updates }} location"
          body: |
            ## ü§ñ Automated Repeater Sync
            
            This PR was automatically generated by syncing with the [MeshMapper API](https://yow.meshmapper.net/repeaters.json).
            
            ### üìä Summary
            
            | Type | Count |
            |------|-------|
            | üÜï New Repeaters | **${{ steps.sync.outputs.new_count }}** |
            | ‚ö†Ô∏è Duplicate ID Repeaters | **${{ steps.sync.outputs.duplicate_count }}** |
            | üìù Updated Names | **${{ steps.sync.outputs.updated_count }}** |
            | üîß State Corrections | **${{ steps.sync.outputs.state_corrections_count }}** |
            | üïê Last Heard Updates | **${{ steps.sync.outputs.last_heard_updates }}** |
            | ‚ö° Power Updates | **${{ steps.sync.outputs.power_updates }}** |
            | üìç Location/City Updates | **${{ steps.sync.outputs.location_updates }}** |
            
            ---
            
            ${{ steps.sync.outputs.new_count != '0' && '### üÜï New Repeaters Added' || '' }}
            ${{ steps.sync.outputs.new_count != '0' && '| Status | Name | ID | Hex ID |' || '' }}
            ${{ steps.sync.outputs.new_count != '0' && '|--------|------|----|--------|' || '' }}
            ${{ steps.sync.outputs.new_table }}
            
            ${{ steps.sync.outputs.duplicate_count != '0' && '### ‚ö†Ô∏è Duplicate ID Repeaters Added' || '' }}
            ${{ steps.sync.outputs.duplicate_count != '0' && '| Status | Existing Name | New Name | ID (Duplicate) | Hex ID (New) |' || '' }}
            ${{ steps.sync.outputs.duplicate_count != '0' && '|--------|---------------|----------|----------------|--------------|' || '' }}
            ${{ steps.sync.outputs.dup_table }}
            
            ${{ steps.sync.outputs.updated_count != '0' && '### üìù Updated Repeater Names' || '' }}
            ${{ steps.sync.outputs.updated_count != '0' && '| ID | Old Name | New Name | Hex ID |' || '' }}
            ${{ steps.sync.outputs.updated_count != '0' && '|----|----------|----------|--------|' || '' }}
            ${{ steps.sync.outputs.upd_table }}
            
            ${{ steps.sync.outputs.state_corrections_count != '0' && '### üîß State Field Corrections' || '' }}
            ${{ steps.sync.outputs.state_corrections_count != '0' && '| Name | ID | Old State | New State |' || '' }}
            ${{ steps.sync.outputs.state_corrections_count != '0' && '|------|----|-----------|-----------|' || '' }}
            ${{ steps.sync.outputs.state_table }}
            
            ---
            <sub>üïê Synced at: `${{ github.event.repository.updated_at }}` | Run: [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})</sub>
          branch: sync-repeaters-${{ github.run_number }}
          delete-branch: true
          labels: |
            automated
            repeater-sync

      - name: Enable Auto-merge (only if no duplicates)
        if: steps.sync.outputs.has_changes == 'true' && steps.sync.outputs.has_duplicates == 'false'
        run: gh pr merge ${{ steps.create_pr.outputs.pull-request-number }} --auto --squash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}