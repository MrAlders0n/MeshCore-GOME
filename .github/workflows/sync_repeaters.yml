name: Sync Repeaters from MeshMapper API

on:
  schedule:
    # Runs every hour at minute 0
    - cron: "0 * * * *"
  workflow_dispatch:  # Allows manual triggering

permissions:
  contents: write
  pull-requests: write

jobs:
  sync-repeaters:
    runs-on: ubuntu-latest
    steps: 
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install pyyaml requests urllib3

      - name: Fetch and sync repeaters
        id: sync
        run: |
          python <<'EOF'
          import os
          import time
          import yaml
          import requests
          from urllib.parse import quote

          VALID_STATES = {
              'duplicate':  'Duplicate',
              'new': 'New',
              'active': 'Active',
              'observer': 'Observer',
              'backbonereserved': 'BackboneReserved',
              'reserved': 'Reserved',
          }

          def normalize_state(state):
              if state is None:
                  return None
              s = str(state).strip()
              if s == "":
                  return None
              s_lower = s.lower()
              return VALID_STATES.get(s_lower, s. capitalize())

          def yaml_quote(s:  str) -> str:
              """Quote for YAML double-quoted scalars."""
              if s is None:
                  return "null"
              return '"' + str(s).replace('\\', '\\\\').replace('"', '\\"') + '"'

          def yaml_scalar(value):
              """Return YAML scalar text (quoted string, null, bool, or plain number)."""
              if value is None:
                  return "null"
              if isinstance(value, bool):
                  return "true" if value else "false"
              if isinstance(value, (int, float)):
                  return str(value)
              return yaml_quote(value)

        def get_city_name(lat, lon):
            if lat is None or lon is None:
                return None
            try:
                headers = {'User-Agent': 'MeshCore-GOME-Sync/1.0'}
                url = f"https://nominatim.openstreetmap.org/reverse? format=json&lat={lat}&lon={lon}&zoom=18"
                resp = requests.get(url, headers=headers, timeout=10)
                resp.raise_for_status()
                data = resp.json()
                address = data.get('address', {})
                return (
                    address.get('neighbourhood')  # More specific (e.g., "Barrhaven West")
                    or address.get('suburb')      # Slightly broader (e.g., "Nepean")
                    or address.get('village')
                    or address.get('town')
                    or address.get('city')
                    or address.get('municipality')
                )
            except Exception as e:
                print(f"  Error geocoding {lat}, {lon}: {e}")
                return None

          def safe(v):
              return "" if v is None else str(v)

          def esc_md(s):
              return str(s).replace("|", "\\|") if s is not None else ""

          def norm_hex(h):
              if h is None: 
                  return None
              s = str(h).strip()
              if s == "":
                  return None
              return s.upper()

          def hex_prefix(h, n=12):
              h2 = norm_hex(h)
              if not h2:
                  return None
              return h2[:n]

          api_url = "https://yow.meshmapper.net/repeaters.json"
          print(f"Fetching repeaters from {api_url}...")
          resp = requests.get(api_url)
          resp.raise_for_status()
          api_repeaters = resp.json()
          print(f"Found {len(api_repeaters)} repeaters in API")

          yml_path = "docs/deployment/data/repeaters.yml"
          with open(yml_path, "r", encoding="utf-8") as f:
              existing_data = yaml.safe_load(f) or {}

          if "repeaters" not in existing_data or existing_data["repeaters"] is None:
              existing_data["repeaters"] = []
          rep_list = existing_data["repeaters"]

          # --- Schema normalization:  ensure these keys always exist ---
          for r in rep_list:
              if not isinstance(r, dict):
                  continue
              if "antenna" not in r:
                  r["antenna"] = None
              if "height_metre" not in r:
                  r["height_metre"] = None
              if "power_watt" not in r: 
                  r["power_watt"] = None

          # Normalize existing states
          state_corrections = []
          for r in rep_list:
              if isinstance(r, dict) and "state" in r:
                  old_state = r. get("state")
                  new_state = normalize_state(old_state)
                  if old_state != new_state: 
                      state_corrections.append({
                          "name": r. get("name", "Unknown"),
                          "id": r.get("id", ""),
                          "old_state": old_state,
                          "new_state": new_state,
                      })
                      r["state"] = new_state
                      print(f"  Corrected state:  {r.get('name')} - '{old_state}' â†’ '{new_state}'")

          # Build lookups
          existing_hex_id_map = {}          # full hex -> repeater
          existing_hex_ids = set()          # full hex set
          existing_hex_prefix_map = {}      # first 12 chars -> repeater (legacy short hex support)
          existing_id_map = {}
          existing_ids = set()

          for r in rep_list:
              if not isinstance(r, dict):
                  continue

              hex_id = norm_hex(r.get("hex_id"))
              if hex_id:
                  existing_hex_id_map[hex_id] = r
                  existing_hex_ids.add(hex_id)
                  pfx = hex_prefix(hex_id, 12)
                  if pfx and pfx not in existing_hex_prefix_map: 
                      existing_hex_prefix_map[pfx] = r

              rid = r.get("id")
              if rid is not None and str(rid).strip() != "":
                  rid_u = str(rid).upper()
                  existing_id_map[rid_u] = r
                  existing_ids.add(rid_u)

          # Trackers
          last_heard_updates = 0

          power_updates = 0
          power_updates_list = []

          location_updates = 0
          location_updates_list = []

          # legacy short -> full hex upgrades
          hex_id_upgrades = []

          new_repeaters = []
          duplicate_repeaters = []
          updated_repeaters = []

          for repeater in api_repeaters: 
              hex_id = norm_hex(repeater.get("hex_id"))
              repeater_id = repeater.get("id")
              api_name = repeater.get("name", "Unknown")
              api_power = repeater.get("power")
              api_lat = repeater.get("lat")
              api_lon = repeater.get("lon")

              if not hex_id:
                  print(f"  Skipping repeater '{api_name}' - no hex_id in API")
                  continue

              hex_id_upper = hex_id
              repeater_id_upper = str(repeater_id).upper() if repeater_id else ""

              # 1) UPDATE existing by FULL hex_id match
              if hex_id_upper in existing_hex_id_map:
                  existing_repeater = existing_hex_id_map[hex_id_upper]
                  existing_name = existing_repeater.get("name", "")

                  # last_heard only when API provided
                  last_heard = repeater.get("last_heard")
                  if last_heard is not None: 
                      old_last_heard = existing_repeater.get("last_heard")
                      if old_last_heard != last_heard:
                          existing_repeater["last_heard"] = last_heard
                          last_heard_updates += 1

                  # power_watt only when API provided a non-empty value
                  if api_power is not None and api_power != "":
                      old_power = existing_repeater. get("power_watt")
                      if old_power != api_power: 
                          existing_repeater["power_watt"] = api_power
                          power_updates += 1
                          power_updates_list.append({
                              "hex_id": hex_id_upper,
                              "id": existing_repeater.get("id", ""),
                              "name": existing_name,
                              "old_power": old_power,
                              "new_power": api_power,
                          })
                          print(f"  Updated power for {existing_name}: {old_power} â†’ {api_power}")

                  # location only when TBD/empty and coords exist
                  current_loc = existing_repeater.get("location", "")
                  if api_lat is not None and api_lon is not None and (not current_loc or "TBD" in str(current_loc)):
                      city = get_city_name(api_lat, api_lon)
                      if city:
                          existing_repeater["location"] = city
                          location_updates += 1
                          location_updates_list.append({
                              "hex_id": hex_id_upper,
                              "id": existing_repeater.get("id", ""),
                              "name": existing_name,
                              "old_location": current_loc or None,
                              "new_location": city,
                          })
                          print(f"  Updated location for {existing_name}: {current_loc} â†’ {city}")
                          time.sleep(1)

                  # name/contact updates
                  if existing_name != api_name: 
                      old_name = existing_name
                      existing_repeater["name"] = api_name
                      encoded_name = quote(api_name)
                      existing_repeater["contact"] = f"meshcore://contact/add? name={encoded_name}&public_key={hex_id_upper}&type=2"
                      updated_repeaters.append({
                          "hex_id":  hex_id_upper,
                          "old_name": old_name,
                          "new_name": api_name,
                          "id": existing_repeater.get("id", ""),
                      })
                  continue

              # 2) LEGACY short hex-id upgrade:  match by first 12 chars
              api_pfx = hex_prefix(hex_id_upper, 12)
              if api_pfx and api_pfx in existing_hex_prefix_map: 
                  existing_repeater = existing_hex_prefix_map[api_pfx]
                  existing_name = existing_repeater.get("name", "")

                  old_hex = existing_repeater.get("hex_id")
                  old_hex_norm = norm_hex(old_hex)

                  if old_hex_norm != hex_id_upper: 
                      existing_repeater["hex_id"] = hex_id_upper

                      # regenerate contact URL with full public_key
                      encoded_name = quote(existing_repeater.get("name", api_name) or api_name)
                      existing_repeater["contact"] = f"meshcore://contact/add?name={encoded_name}&public_key={hex_id_upper}&type=2"

                      hex_id_upgrades.append({
                          "name": existing_repeater.get("name", api_name),
                          "id":  existing_repeater.get("id", ""),
                          "prefix": api_pfx,
                          "old_hex":  old_hex,
                          "new_hex": hex_id_upper,
                      })
                      print(f"  Upgraded legacy hex_id for {existing_name}: {old_hex} â†’ {hex_id_upper}")

                      # last_heard
                      last_heard = repeater.get("last_heard")
                      if last_heard is not None:
                          old_last_heard = existing_repeater.get("last_heard")
                          if old_last_heard != last_heard:
                              existing_repeater["last_heard"] = last_heard
                              last_heard_updates += 1

                      # power_watt
                      if api_power is not None and api_power != "":
                          old_power = existing_repeater.get("power_watt")
                          if old_power != api_power:
                              existing_repeater["power_watt"] = api_power
                              power_updates += 1
                              power_updates_list.append({
                                  "hex_id": hex_id_upper,
                                  "id": existing_repeater.get("id", ""),
                                  "name": existing_repeater.get("name", api_name),
                                  "old_power": old_power,
                                  "new_power": api_power,
                              })
                      continue

              # 3) NEW repeater (or duplicate id)
              is_duplicate = repeater_id_upper in existing_ids
              state = "Duplicate" if is_duplicate else "New"

              encoded_name = quote(api_name)
              contact = f"meshcore://contact/add?name={encoded_name}&public_key={hex_id_upper}&type=2"

              location = "TBD"
              if api_lat is not None and api_lon is not None:
                  city = get_city_name(api_lat, api_lon)
                  if city:
                      location = city
                      time.sleep(1)

              new_entry = {
                  "id": repeater_id_upper or None,
                  "name": api_name,
                  "antenna": None,        # new entries should be null
                  "height_metre":  None,   # manual field always present
                  "location": location if location is not None else None,
                  "contact": contact if contact is not None else None,
                  "state": state,
                  "hex_id": hex_id_upper,
                  "last_heard": repeater.get("last_heard") if repeater.get("last_heard") is not None else None,
                  "power_watt": None,     # always present, possibly overridden
              }

              if api_power is not None and api_power != "": 
                  new_entry["power_watt"] = api_power
                  # include new repeater power in the PR power summary (old=null)
                  power_updates_list.append({
                      "hex_id": hex_id_upper,
                      "id":  new_entry.get("id", ""),
                      "name": api_name,
                      "old_power": None,
                      "new_power": api_power,
                  })

              if is_duplicate:
                  existing_repeater_name = existing_id_map.get(repeater_id_upper, {}).get("name", "Unknown")
                  new_entry["existing_name"] = existing_repeater_name
                  duplicate_repeaters.append(new_entry)
              else:
                  new_repeaters.append(new_entry)

          all_new = new_repeaters + duplicate_repeaters
          has_changes = (
              len(all_new) > 0
              or len(updated_repeaters) > 0
              or len(state_corrections) > 0
              or len(hex_id_upgrades) > 0
              or last_heard_updates > 0
              or power_updates > 0
              or location_updates > 0
          )

          # Write YAML manually (only if changes)
          if has_changes: 
              if all_new:
                  rep_list. extend(all_new)

              with open(yml_path, "w", encoding="utf-8") as f:
                  f.write("repeaters:\n")
                  for r in rep_list:
                      if not isinstance(r, dict):
                          continue

                      f.write(f"  - id: {yaml_scalar(r.get('id'))}\n")
                      f.write(f"    name: {yaml_scalar(r.get('name'))}\n")
                      f.write(f"    antenna: {yaml_scalar(r.get('antenna'))}\n")
                      f.write(f"    height_metre: {yaml_scalar(r.get('height_metre'))}\n")
                      f.write(f"    location: {yaml_scalar(r.get('location'))}\n")
                      f.write(f"    contact: {yaml_scalar(r.get('contact'))}\n")

                      if "state" in r:
                          f.write(f"    state: {yaml_scalar(r.get('state'))}\n")
                      if "hex_id" in r:
                          f.write(f"    hex_id: {yaml_scalar(r.get('hex_id'))}\n")
                      if "last_heard" in r: 
                          f.write(f"    last_heard: {yaml_scalar(r.get('last_heard'))}\n")

                      # Always write power_watt (null if missing)
                      f.write(f"    power_watt: {yaml_scalar(r.get('power_watt'))}\n")
                      f.write("\n")

          # Emit GitHub Action outputs
          output_file = os.environ.get("GITHUB_OUTPUT")
          if output_file:
              with open(output_file, "a", encoding="utf-8") as of:
                  if has_changes:
                      of. write(f"new_count={len(new_repeaters)}\n")
                      of.write(f"duplicate_count={len(duplicate_repeaters)}\n")
                      of.write(f"updated_count={len(updated_repeaters)}\n")
                      of.write(f"state_corrections_count={len(state_corrections)}\n")
                      of. write(f"hex_id_upgrades_count={len(hex_id_upgrades)}\n")
                      of.write(f"last_heard_updates={last_heard_updates}\n")
                      of.write(f"power_updates={power_updates}\n")
                      of. write(f"location_updates={location_updates}\n")
                      of.write(f"has_duplicates={'true' if len(duplicate_repeaters) > 0 else 'false'}\n")
                      of.write("has_changes=true\n")

                      new_table = "\n".join([
                          f"| ğŸ†• | {esc_md(r.get('name'))} | `{safe(r.get('id'))}` | `{(norm_hex(r.get('hex_id'))[:16] + '... ') if r.get('hex_id') else ''}` |"
                          for r in new_repeaters
                      ])
                      dup_table = "\n".join([
                          f"| âš ï¸ | {esc_md(r.get('existing_name','Unknown'))} | {esc_md(r.get('name'))} | `{safe(r.get('id'))}` | `{(norm_hex(r.get('hex_id'))[:16] + '...') if r.get('hex_id') else ''}` |"
                          for r in duplicate_repeaters
                      ])
                      upd_table = "\n".join([
                          f"| `{safe(r.get('id'))}` | {esc_md(r.get('old_name'))} | {esc_md(r.get('new_name'))} | `{(norm_hex(r.get('hex_id'))[:16] + '...') if r.get('hex_id') else ''}` |"
                          for r in updated_repeaters
                      ])
                      state_table = "\n".join([
                          f"| {esc_md(r.get('name'))} | `{safe(r.get('id'))}` | `{safe(r.get('old_state'))}` | `{safe(r.get('new_state'))}` |"
                          for r in state_corrections
                      ])
                      location_table = "\n".join([
                          f"| {esc_md(r.get('name'))} | `{safe(r.get('id'))}` | `{(norm_hex(r.get('hex_id'))[:16] + '...') if r.get('hex_id') else ''}` | {esc_md(r.get('old_location') or 'TBD')} | {esc_md(r. get('new_location') or '')} |"
                          for r in location_updates_list
                      ])
                      power_table = "\n".join([
                          f"| {esc_md(r.get('name'))} | `{safe(r.get('id'))}` | `{(norm_hex(r.get('hex_id'))[:16] + '...') if r.get('hex_id') else ''}` | {esc_md(safe(r.get('old_power')))} | {esc_md(safe(r.get('new_power')))} |"
                          for r in power_updates_list
                      ])
                      hex_upgrade_table = "\n".join([
                          f"| {esc_md(r.get('name'))} | `{safe(r.get('id'))}` | `{esc_md(r.get('prefix'))}` | "
                          f"`{esc_md(safe(r.get('old_hex')))}` | "
                          f"`{esc_md(safe(r.get('new_hex')))}` |"
                          for r in hex_id_upgrades
                      ])

                      of.write(f"new_table<<EOF\n{new_table}\nEOF\n")
                      of.write(f"dup_table<<EOF\n{dup_table}\nEOF\n")
                      of.write(f"upd_table<<EOF\n{upd_table}\nEOF\n")
                      of.write(f"state_table<<EOF\n{state_table}\nEOF\n")
                      of.write(f"location_table<<EOF\n{location_table}\nEOF\n")
                      of.write(f"power_table<<EOF\n{power_table}\nEOF\n")
                      of.write(f"hex_upgrade_table<<EOF\n{hex_upgrade_table}\nEOF\n")
                  else:
                      of.write("has_changes=false\n")
          EOF

      - name: Create Pull Request
        if: steps.sync.outputs.has_changes == 'true'
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:
          token:  ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Sync repeaters from MeshMapper API (${{ steps.sync.outputs.new_count }} new, ${{ steps.sync.outputs.power_updates }} power updates)"
          title: "ğŸ”„ Sync:  ${{ steps.sync.outputs.new_count }} new, ${{ steps.sync.outputs.power_updates }} power, ${{ steps.sync.outputs. location_updates }} location"
          body: |
            ## ğŸ¤– Automated Repeater Sync

            This PR was automatically generated by syncing with the [MeshMapper API](https://yow.meshmapper.net/repeaters. json).

            ${{ steps.sync.outputs.has_duplicates == 'true' && '> **âš ï¸ WARNING:** This PR contains duplicate ID entries that require manual review before merging!' || '> âœ… **Safe to auto-merge**' }}

            ### ğŸ“Š Summary

            | Type | Count |
            |------|-------|
            | ğŸ†• New Repeaters | **${{ steps.sync.outputs.new_count }}** |
            | âš ï¸ Duplicate ID Repeaters | **${{ steps.sync.outputs.duplicate_count }}** |
            | ğŸ“ Updated Names | **${{ steps.sync. outputs.updated_count }}** |
            | ğŸ”§ State Corrections | **${{ steps.sync.outputs.state_corrections_count }}** |
            | ğŸ”‘ Hex ID Upgrades (legacy short â†’ full) | **${{ steps.sync.outputs.hex_id_upgrades_count }}** |
            | ğŸ• Last Heard Updates | **${{ steps.sync.outputs. last_heard_updates }}** |
            | âš¡ Power Updates | **${{ steps.sync. outputs.power_updates }}** |
            | ğŸ“ Location/City Updates | **${{ steps.sync.outputs.location_updates }}** |

            ### ğŸ†• New Repeaters
            | Type | Name | ID | Hex ID |
            |------|------|----|--------|
            ${{ steps.sync.outputs.new_table }}

            ### âš ï¸ Duplicate ID Repeaters
            | Type | Existing Name | New Name | ID | Hex ID |
            |------|---------------|----------|----|--------|
            ${{ steps.sync.outputs.dup_table }}

            ### ğŸ“ Updated Names
            | ID | Old Name | New Name | Hex ID |
            |----|----------|----------|--------|
            ${{ steps.sync. outputs.upd_table }}

            ### ğŸ”‘ Hex ID Upgrades (legacy short â†’ full)
            These entries previously stored only the first 12 characters of `hex_id`. If an API `hex_id` shares the same first 12 characters, the workflow upgrades the stored `hex_id` and regenerates the `contact` URL.

            | Name | ID | Prefix (12) | Old Hex ID | New Hex ID |
            |------|----|-------------|------------|------------|
            ${{ steps.sync.outputs.hex_upgrade_table }}

            ### âš¡ Power Updates
            | Name | ID | Hex ID | Old Power | New Power |
            |------|----|--------|-----------|-----------|
            ${{ steps.sync.outputs.power_table }}

            ### ğŸ“ Location/City Updates
            | Name | ID | Hex ID | Old Location | New Location |
            |------|----|-------|--------------|--------------|
            ${{ steps. sync.outputs.location_table }}

            ### ğŸ”§ State Corrections
            | Name | ID | Old State | New State |
            |------|----|-----------|-----------|
            ${{ steps.sync.outputs.state_table }}

            ---
            _Generated automatically by the sync workflow._

      - name: Enable Auto-merge (only if no duplicates)
        if: steps.sync.outputs.has_changes == 'true' && steps. sync.outputs.has_duplicates == 'false'
        run: |
          gh pr merge ${{ steps.create_pr.outputs.pull-request-number }} --auto --squash
        env:
          GH_TOKEN: ${{ secrets. GITHUB_TOKEN }}
