name: Sync Repeaters from MeshMapper API

on:  
  schedule:    
    # Runs every hour at the top of the hour
    - cron: '0 * * * *'
  workflow_dispatch:    # Allows manual triggering

permissions:
  contents: write
  pull-requests: write

jobs:    
  sync-repeaters:     
    runs-on: ubuntu-latest
    steps:  
      - name: Checkout repository
        uses: actions/checkout@v4
        with:  
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:   
          python-version: '3.x'

      - name: Install dependencies
        run: pip install pyyaml requests urllib3

      - name:   Fetch and sync repeaters
        id: sync
        run: |
          python << 'EOF'
          import yaml
          import requests
          import json
          import os
          from urllib.parse import quote
          from datetime import datetime

          # Define valid state values with proper capitalization
          VALID_STATES = {
              'duplicate':  'Duplicate',
              'new': 'New',
              'active': 'Active',
              'observer': 'Observer',
              'reserved': 'Reserved'
          }

          def normalize_state(state):
              """Normalize state to proper capitalization"""
              if not state:
                  return None
              state_lower = str(state).lower()
              return VALID_STATES.get(state_lower, state. capitalize())

          # Fetch repeaters from API
          api_url = 'https://yow.meshmapper.net/repeaters.json'
          print(f"Fetching repeaters from {api_url}...")
          response = requests.get(api_url)
          response.raise_for_status()
          api_repeaters = response.json()
          print(f"Found {len(api_repeaters)} repeaters in API")

          # Load existing YAML file
          yml_path = 'docs/deployment/data/repeaters.yml'
          with open(yml_path, 'r') as f:
              existing_data = yaml.safe_load(f)

          # Track state corrections
          state_corrections = []

          # Normalize all existing states first
          for r in existing_data. get('repeaters', []):
              if 'state' in r:
                  old_state = r['state']
                  new_state = normalize_state(old_state)
                  if old_state != new_state: 
                      state_corrections.append({
                          'name': r. get('name', 'Unknown'),
                          'id': r.get('id', ''),
                          'old_state': old_state,
                          'new_state': new_state
                      })
                      r['state'] = new_state
                      print(f"  Corrected state:  {r. get('name')} - '{old_state}' â†’ '{new_state}'")

          # Create a map of hex_id to repeater for quick lookup
          existing_hex_id_map = {}
          existing_hex_ids = set()
          for r in existing_data.get('repeaters', []):
              hex_id = r.get('hex_id')
              if hex_id:  # Only add if hex_id exists and is not None
                  hex_id_upper = str(hex_id).upper()
                  existing_hex_id_map[hex_id_upper] = r
                  existing_hex_ids.add(hex_id_upper)
          
          # Create map of id to repeater for finding duplicate names
          existing_id_map = {}
          existing_ids = set()
          for r in existing_data.get('repeaters', []):
              rep_id = r.get('id')
              if rep_id:      
                  rep_id_upper = str(rep_id).upper()
                  existing_ids.add(rep_id_upper)
                  existing_id_map[rep_id_upper] = r
          
          print(f"Existing YAML has {len(existing_hex_ids)} unique hex_ids and {len(existing_ids)} unique ids")
          if state_corrections:
              print(f"Corrected {len(state_corrections)} state field(s)")

          # Track changes
          new_repeaters = []
          duplicate_repeaters = []
          updated_repeaters = []
          
          for repeater in api_repeaters:    
              hex_id = repeater.get('hex_id')
              repeater_id = repeater.get('id')
              api_name = repeater.get('name', 'Unknown')
              
              # Skip if no hex_id
              if not hex_id:  
                  print(f"  Skipping repeater '{api_name}' - no hex_id in API")
                  continue
              
              # Normalize hex_id and id to uppercase for comparison
              hex_id_upper = str(hex_id).upper()
              repeater_id_upper = str(repeater_id).upper() if repeater_id else ''
              
              # Check if this hex_id already exists
              if hex_id_upper in existing_hex_id_map:  
                  # Update existing repeater if name is different
                  existing_repeater = existing_hex_id_map[hex_id_upper]
                  existing_name = existing_repeater.get('name', '')
                  
                  if existing_name != api_name:   
                      old_name = existing_name
                      existing_repeater['name'] = api_name
                      
                      # Update contact URL with new name
                      encoded_name = quote(api_name)
                      existing_repeater['contact'] = f"meshcore://contact/add? name={encoded_name}&public_key={hex_id_upper}&type=2"
                      
                      updated_repeaters.append({
                          'hex_id': hex_id_upper,
                          'old_name': old_name,
                          'new_name': api_name,
                          'id': existing_repeater.get('id', '')
                      })
                      print(f"  Updated repeater:   '{old_name}' â†’ '{api_name}' (hex_id: {hex_id_upper[: 16]}... )")
                  
                  # Update last_heard timestamp
                  last_heard = repeater.get('last_heard')
                  if last_heard:      
                      existing_repeater['last_heard'] = last_heard
                  
                  continue
              
              # This is a new repeater (new hex_id)
              # Determine state:  "duplicate" if id already exists, "new" otherwise
              is_duplicate = repeater_id_upper in existing_ids
              state = "Duplicate" if is_duplicate else "New"  # Already properly capitalized
              
              # Generate contact URL with URL-encoded name
              encoded_name = quote(api_name)
              contact = f"meshcore://contact/add?name={encoded_name}&public_key={hex_id_upper}&type=2"
              
              # Get last_heard timestamp
              last_heard = repeater.get('last_heard')
              
              new_entry = {
                  'id': repeater_id_upper,
                  'name': api_name,
                  'antenna': 'TBD',
                  'location': 'TBD (~X.X m)',
                  'contact': contact,
                  'state': state,
                  'hex_id': hex_id_upper,
                  'last_heard': last_heard
              }
              
              if is_duplicate:  
                  # Get the existing repeater name
                  existing_repeater_name = existing_id_map.get(repeater_id_upper, {}).get('name', 'Unknown')
                  new_entry['existing_name'] = existing_repeater_name
                  duplicate_repeaters.append(new_entry)
                  print(f"  âš ï¸  Duplicate ID:  {api_name} (id: {repeater_id_upper}, hex_id: {hex_id_upper[:16]}.. .) - existing: {existing_repeater_name}")
              else:
                  new_repeaters.append(new_entry)
                  print(f"  New repeater:  {api_name} (id:  {repeater_id_upper}, hex_id: {hex_id_upper[:16]}...)")

          # Check if there are any changes
          all_new = new_repeaters + duplicate_repeaters
          has_changes = len(all_new) > 0 or len(updated_repeaters) > 0 or len(state_corrections) > 0
          
          if has_changes:  
              # Add ALL new repeaters (including duplicates) to existing list
              if all_new:  
                  existing_data['repeaters']. extend(all_new)
              
              # Write updated YAML with custom formatting
              with open(yml_path, 'w') as f:
                  # Custom YAML dump to maintain formatting
                  f.write("repeaters:\n")
                  for repeater in existing_data['repeaters']: 
                      rep_id = repeater.get("id", "")
                      f.write(f'  - id: "{rep_id}"\n')
                      f.write(f'    name: "{repeater.get("name", "")}"\n')
                      f.write(f'    antenna: "{repeater.get("antenna", "TBD")}"\n')
                      f.write(f'    location: "{repeater.get("location", "TBD")}"\n')
                      
                      contact = repeater.get('contact')
                      if contact:        
                          f.write(f'    contact: "{contact}"\n')
                      else:     
                          f.write(f'    contact: null\n')
                      
                      # Add state field if it exists (now normalized)
                      if 'state' in repeater:  
                          f.write(f'    state: "{repeater["state"]}"\n')
                      
                      # Add hex_id field if it exists
                      if 'hex_id' in repeater:  
                          hex_id_val = repeater["hex_id"]
                          if hex_id_val:
                              f.write(f'    hex_id: "{hex_id_val}"\n')
                          else:
                              f. write(f'    hex_id: null\n')
                      
                      # Add last_heard field if it exists
                      if 'last_heard' in repeater:  
                          last_heard = repeater['last_heard']
                          if last_heard:  
                              f.write(f'    last_heard: {last_heard}\n')
                          else:  
                              f.write(f'    last_heard: null\n')
                      
                      f.write('\n')
              
              # Output summary
              if state_corrections:
                  print(f"\nâœ… Corrected {len(state_corrections)} state field(s)")
              if new_repeaters:
                  print(f"âœ… Added {len(new_repeaters)} new repeater(s)")
              if duplicate_repeaters:
                  print(f"âš ï¸  Added {len(duplicate_repeaters)} duplicate repeater(s)")
              if updated_repeaters:  
                  print(f"âœ… Updated {len(updated_repeaters)} repeater name(s)")
              
              # Write to GitHub output using GITHUB_OUTPUT env var
              output_file = os.environ.get('GITHUB_OUTPUT')
              if output_file:
                  with open(output_file, 'a') as f:
                      f.write(f"new_count={len(new_repeaters)}\n")
                      f.write(f"duplicate_count={len(duplicate_repeaters)}\n")
                      f.write(f"updated_count={len(updated_repeaters)}\n")
                      f.write(f"state_corrections_count={len(state_corrections)}\n")
                      f. write(f"has_duplicates={'true' if len(duplicate_repeaters) > 0 else 'false'}\n")
                      f.write("has_changes=true\n")
                      
                      # Create formatted table for new repeaters using proper delimiter
                      new_table_rows = []
                      for r in new_repeaters:
                          # Escape pipe characters in names
                          name_escaped = r['name'].replace('|', '\\|')
                          new_table_rows.append(f"| ğŸ†• | {name_escaped} | `{r['id']}` | `{r['hex_id'][:16]}...` |")
                      new_table = "\n".join(new_table_rows) if new_table_rows else ""
                      
                      # Use heredoc for multiline output
                      f.write("new_table<<EOF\n")
                      f. write(new_table)
                      f.write("\nEOF\n")
                      
                      # Create formatted table for duplicate repeaters with existing name
                      dup_table_rows = []
                      for r in duplicate_repeaters:  
                          name_escaped = r['name'].replace('|', '\\|')
                          existing_name_escaped = r. get('existing_name', 'Unknown').replace('|', '\\|')
                          dup_table_rows.append(f"| âš ï¸ | {existing_name_escaped} | {name_escaped} | `{r['id']}` | `{r['hex_id'][:16]}...` |")
                      dup_table = "\n". join(dup_table_rows) if dup_table_rows else ""
                      
                      f.write("dup_table<<EOF\n")
                      f.write(dup_table)
                      f.write("\nEOF\n")
                      
                      # Create formatted table for updated repeaters
                      upd_table_rows = []
                      for r in updated_repeaters:
                          old_name_escaped = r['old_name'].replace('|', '\\|')
                          new_name_escaped = r['new_name'].replace('|', '\\|')
                          upd_table_rows.append(f"| `{r['id']}` | {old_name_escaped} | {new_name_escaped} | `{r['hex_id'][:16]}...` |")
                      upd_table = "\n".join(upd_table_rows) if upd_table_rows else ""
                      
                      f.write("upd_table<<EOF\n")
                      f.write(upd_table)
                      f.write("\nEOF\n")
                      
                      # Create formatted table for state corrections
                      state_table_rows = []
                      for r in state_corrections:
                          name_escaped = r['name'].replace('|', '\\|')
                          state_table_rows. append(f"| {name_escaped} | `{r['id']}` | `{r['old_state']}` | `{r['new_state']}` |")
                      state_table = "\n".join(state_table_rows) if state_table_rows else ""
                      
                      f.write("state_table<<EOF\n")
                      f.write(state_table)
                      f.write("\nEOF\n")
          else:
              print("\nâ„¹ï¸ No changes needed")
              output_file = os.environ.get('GITHUB_OUTPUT')
              if output_file:
                  with open(output_file, 'a') as f:
                      f.write("new_count=0\n")
                      f.write("duplicate_count=0\n")
                      f.write("updated_count=0\n")
                      f.write("state_corrections_count=0\n")
                      f.write("has_duplicates=false\n")
                      f.write("has_changes=false\n")
                      f.write("new_table<<EOF\n\nEOF\n")
                      f.write("dup_table<<EOF\n\nEOF\n")
                      f.write("upd_table<<EOF\n\nEOF\n")
                      f.write("state_table<<EOF\n\nEOF\n")
          EOF

      - name: Create Pull Request
        if: steps.sync.outputs.has_changes == 'true'
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:  
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message:  "Sync repeaters from MeshMapper API (${{ steps.sync.outputs.new_count }} new, ${{ steps.sync.outputs.duplicate_count }} duplicate, ${{ steps.sync.outputs.updated_count }} updated, ${{ steps.sync.outputs.state_corrections_count }} state corrections)"
          title: "ğŸ”„ Sync:  ${{ steps.sync.outputs. new_count }} new, ${{ steps.sync.outputs.duplicate_count }} duplicate, ${{ steps. sync.outputs.updated_count }} updated"
          body: |
            ## ğŸ¤– Automated Repeater Sync
            
            This PR was automatically generated by syncing with the [MeshMapper API](https://yow.meshmapper.net/repeaters.json).
            
            ${{ steps.sync.outputs.has_duplicates == 'true' && '> **âš ï¸ WARNING:** This PR contains duplicate ID entries that require manual review before merging!' || '> âœ… **Safe to auto-merge:** No duplicate IDs detected.' }}
            
            ### ğŸ“Š Summary
            
            | Type | Count |
            |------|-------|
            | ğŸ†• New Repeaters | **${{ steps.sync.outputs. new_count }}** |
            | âš ï¸ Duplicate ID Repeaters | **${{ steps.sync.outputs.duplicate_count }}** |
            | ğŸ“ Updated Names | **${{ steps.sync.outputs.updated_count }}** |
            | ğŸ”§ State Corrections | **${{ steps.sync.outputs.state_corrections_count }}** |
            
            ---
            
            ${{ steps. sync.outputs.new_count != '0' && '### ğŸ†• New Repeaters Added' || '' }}
            ${{ steps.sync.outputs.new_count != '0' && '
            | Status | Name | ID | Hex ID |
            |--------|------|----|--------|' || '' }}
            ${{ steps.sync.outputs.new_table }}
            
            ${{ steps. sync.outputs.duplicate_count != '0' && '### âš ï¸ Duplicate ID Repeaters Added' || '' }}
            ${{ steps.sync.outputs.duplicate_count != '0' && '
            These repeaters have a duplicate `id` field but a new `hex_id`. This typically indicates hardware was replaced or reconfigured. 
            
            | Status | Existing Name | New Name | ID (Duplicate) | Hex ID (New) |
            |--------|---------------|----------|----------------|--------------|' || '' }}
            ${{ steps.sync.outputs. dup_table }}
            
            ${{ steps.sync.outputs. updated_count != '0' && '### ğŸ“ Updated Repeater Names' || '' }}
            ${{ steps.sync.outputs.updated_count != '0' && '
            | ID | Old Name | New Name | Hex ID |
            |----|----------|----------|--------|' || '' }}
            ${{ steps.sync.outputs.upd_table }}
            
            ${{ steps.sync.outputs.state_corrections_count != '0' && '### ğŸ”§ State Field Corrections' || '' }}
            ${{ steps.sync.outputs. state_corrections_count != '0' && '
            The following repeater state fields were corrected to use proper capitalization:
            
            | Name | ID | Old State | New State |
            |------|----|-----------|-----------|' || '' }}
            ${{ steps.sync.outputs.state_table }}
            
            ---
            
            ### ğŸ“‹ Legend
            
            - ğŸ†• **New** - Completely new repeater entry with unique `id` and `hex_id`
            - âš ï¸ **Duplicate** - New `hex_id` but duplicate `id` field (marked as `state:  Duplicate` in YAML)
              - This usually means the hardware changed but kept the same ID
              - Both entries are kept for tracking purposes
              - Review to determine if old entry should be removed
            
            ### ğŸ“ Valid State Values
            
            The workflow automatically normalizes state fields to proper capitalization:
            - `New` - New repeater entry
            - `Active` - Active repeater
            - `Duplicate` - Duplicate ID detected
            - `Observer` - Observer status
            - `Reserved` - Reserved for future use
            
            ### â„¹ï¸ Notes
            
            - The [MeshMapper JSON API](https://yow.meshmapper.net/repeaters. json) is the authoritative source
            - All new entries have `antenna: TBD` and `location: TBD (~X.X m)` by default
            - Contact URLs are automatically generated from the repeater name and hex_id
            - Name updates are applied automatically when the API has different names
            - State fields are automatically normalized to proper capitalization
            - Duplicate repeaters are added to YAML with `state: Duplicate` for manual review
            
            ### âœ… Next Steps
            
            ${{ steps.sync.outputs.has_duplicates == 'true' && '1. **âš ï¸ Review duplicate entries carefully**
            2.  Determine if old entries should be removed
            3. Update `antenna` and `location` fields for new repeaters
            4. Manually merge when ready' || '1. Review the changes in the **Files changed** tab
            2. Update `antenna` and `location` fields for new repeaters
            3. PR will auto-merge after checks pass âœ¨' }}
            
            ---
            
            <sub>ğŸ• Synced at: `${{ github.event.repository.updated_at }}` | Run: [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})</sub>
          branch: sync-repeaters-${{ github.run_number }}
          delete-branch: true
          labels: |
            automated
            repeater-sync

      - name: Enable Auto-merge (only if no duplicates)
        if: steps.sync.outputs.has_changes == 'true' && steps.sync.outputs.has_duplicates == 'false'
        run: |
          gh pr merge ${{ steps.create_pr.outputs.pull-request-number }} --auto --squash
        env:
          GH_TOKEN: ${{ secrets. GITHUB_TOKEN }}
