name: Sync Repeaters from MeshMapper API

on:
  schedule:
    # Runs every hour at minute 0
    - cron: "0 * * * *"
  workflow_dispatch: # Allows manual triggering

permissions:
  contents: write
  pull-requests: write

jobs:
  sync-repeaters:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install "ruamel.yaml<0.18" requests urllib3

      - name: Fetch and sync repeaters
        id: sync
        run: |
          python << 'EOF'
          from ruamel.yaml import YAML
          from ruamel.yaml.comments import CommentedMap
          import requests
          import os
          import time
          from io import StringIO
          from urllib.parse import quote
          import re

          # --- YAML setup (round-trip) ---
          yaml = YAML()
          yaml.preserve_quotes = True
          yaml.indent(mapping=2, sequence=2, offset=2)
          yaml.width = 4096  # avoid wrapping lines

          VALID_STATES = {
              'duplicate': 'Duplicate',
              'new': 'New',
              'active': 'Active',
              'observer': 'Observer',
              'backbonereserved': 'BackboneReserved',
              'reserved': 'Reserved'
          }

          def normalize_state(state):
              if state is None:
                  return None
              state_lower = str(state).lower()
              return VALID_STATES.get(state_lower, state.capitalize())

          def get_city_name(lat, lon):
              if lat is None or lon is None:
                  return None
              try:
                  headers = {'User-Agent': 'MeshCore-GOME-Sync/1.0'}
                  url = f"https://nominatim.openstreetmap.org/reverse?format=json&lat={lat}&lon={lon}&zoom=10"
                  response = requests.get(url, headers=headers, timeout=10)
                  response.raise_for_status()
                  data = response.json()
                  address = data.get('address', {})
                  return address.get('city') or address.get('town') or address.get('village') or address.get('municipality') or address.get('suburb')
              except Exception as e:
                  print(f"  Error geocoding {lat}, {lon}: {e}")
                  return None

          # --- Fetch API data ---
          api_url = 'https://yow.meshmapper.net/repeaters.json'
          print(f"Fetching repeaters from {api_url}...")
          resp = requests.get(api_url)
          resp.raise_for_status()
          api_repeaters = resp.json()
          print(f"Found {len(api_repeaters)} repeaters in API")

          # --- Load existing YAML with ruamel (preserves formatting) ---
          yml_path = 'docs/deployment/data/repeaters.yml'
          with open(yml_path, 'r', encoding='utf-8') as fh:
              existing_data = yaml.load(fh) or CommentedMap()

          existing_data.setdefault('repeaters', [])
          rep_seq = existing_data['repeaters']  # CommentedSeq

          # Trackers
          state_corrections = []
          last_heard_updates = 0
          power_updates = 0
          location_updates = 0
          location_updates_list = []
          new_repeaters = []
          duplicate_repeaters = []
          updated_repeaters = []

          # Normalize existing states first
          for r in rep_seq:
              if 'state' in r:
                  old_state = r['state']
                  new_state = normalize_state(old_state)
                  if old_state != new_state:
                      state_corrections.append({
                          'name': r.get('name', 'Unknown'),
                          'id': r.get('id', ''),
                          'old_state': old_state,
                          'new_state': new_state
                      })
                      r['state'] = new_state
                      print(f"  Corrected state: {r.get('name')} - '{old_state}' â†’ '{new_state}'")

          # Build lookup maps (uppercase keys)
          existing_hex_id_map = {}
          existing_hex_ids = set()
          existing_id_map = {}
          existing_ids = set()
          for r in rep_seq:
              hex_id = r.get('hex_id')
              if hex_id:
                  h = str(hex_id).upper()
                  existing_hex_id_map[h] = r
                  existing_hex_ids.add(h)
              rid = r.get('id')
              if rid:
                  rid_u = str(rid).upper()
                  existing_id_map[rid_u] = r
                  existing_ids.add(rid_u)

          print(f"Existing YAML has {len(existing_hex_ids)} unique hex_ids and {len(existing_ids)} unique ids")

          # --- Process API repeaters ---
          for repeater in api_repeaters:
              hex_id = repeater.get('hex_id')
              repeater_id = repeater.get('id')
              api_name = repeater.get('name', 'Unknown')
              api_power = repeater.get('power')
              api_lat = repeater.get('lat')
              api_lon = repeater.get('lon')

              if not hex_id:
                  print(f"  Skipping repeater '{api_name}' - no hex_id in API")
                  continue

              hex_id_upper = str(hex_id).upper()
              repeater_id_upper = str(repeater_id).upper() if repeater_id else ''

              # Existing entry (match by hex_id)
              if hex_id_upper in existing_hex_id_map:
                  existing_repeater = existing_hex_id_map[hex_id_upper]
                  existing_name = existing_repeater.get('name', '')

                  # last_heard update (only if API provided)
                  last_heard = repeater.get('last_heard')
                  if last_heard is not None:
                      old_last_heard = existing_repeater.get('last_heard')
                      if old_last_heard != last_heard:
                          existing_repeater['last_heard'] = last_heard
                          last_heard_updates += 1

                  # power_watt update (only if API provided)
                  if api_power is not None:
                      old_power = existing_repeater.get('power_watt')
                      if old_power != api_power:
                          existing_repeater['power_watt'] = api_power
                          power_updates += 1
                          print(f"  Updated power for {existing_name}: {old_power} â†’ {api_power}")

                  # location only if TBD/empty and coords exist
                  current_loc = existing_repeater.get('location', '')
                  if api_lat is not None and api_lon is not None and (not current_loc or 'TBD' in current_loc):
                      city = get_city_name(api_lat, api_lon)
                      if city:
                          existing_repeater['location'] = city
                          location_updates += 1
                          location_updates_list.append({
                              'hex_id': hex_id_upper,
                              'id': existing_repeater.get('id', ''),
                              'name': existing_name,
                              'old_location': current_loc or None,
                              'new_location': city,
                          })
                          print(f"  Updated location for {existing_name}: {current_loc} â†’ {city}")
                          time.sleep(1)

                  # name/contact
                  if existing_name != api_name:
                      old_name = existing_name
                      existing_repeater['name'] = api_name
                      encoded_name = quote(api_name)
                      existing_repeater['contact'] = f"meshcore://contact/add?name={encoded_name}&public_key={hex_id_upper}&type=2"
                      updated_repeaters.append({
                          'hex_id': hex_id_upper,
                          'old_name': old_name,
                          'new_name': api_name,
                          'id': existing_repeater.get('id', '')
                      })
                  continue

              # New repeater
              is_duplicate = repeater_id_upper in existing_ids
              state = "Duplicate" if is_duplicate else "New"

              encoded_name = quote(api_name)
              contact = f"meshcore://contact/add?name={encoded_name}&public_key={hex_id_upper}&type=2"

              location = 'TBD'
              if api_lat is not None and api_lon is not None:
                  city = get_city_name(api_lat, api_lon)
                  if city:
                      location = city
                      time.sleep(1)

              # Build new entry using CommentedMap; use None for missing values so YAML emits null
              new_entry = CommentedMap()
              new_entry['id'] = repeater_id_upper or None
              new_entry['name'] = api_name
              new_entry['antenna'] = 'TBD'
              new_entry['location'] = location if location is not None else None
              new_entry['contact'] = contact if contact is not None else None
              new_entry['state'] = state
              new_entry['hex_id'] = hex_id_upper
              new_entry['last_heard'] = repeater.get('last_heard') if repeater.get('last_heard') is not None else None
              # IMPORTANT: keep power as None when absent so YAML emits `null`
              new_entry['power_watt'] = api_power if api_power is not None else None

              if is_duplicate:
                  existing_repeater_name = existing_id_map.get(repeater_id_upper, {}).get('name', 'Unknown')
                  new_entry['existing_name'] = existing_repeater_name
                  duplicate_repeaters.append(new_entry)
              else:
                  new_repeaters.append(new_entry)

          # --- Decide changes and write back ---
          all_new = new_repeaters + duplicate_repeaters
          has_changes = (
              len(all_new) > 0
              or len(updated_repeaters) > 0
              or len(state_corrections) > 0
              or last_heard_updates > 0
              or power_updates > 0
              or location_updates > 0
          )

          if has_changes:
              # append new items, remember start index
              if all_new:
                  start_idx = len(rep_seq)
                  for ne in all_new:
                      rep_seq.append(ne)
              else:
                  start_idx = len(rep_seq)  # no new appends

              # Dump to string first so we can insert blank lines only before newly appended sequence items
              sio = StringIO()
              yaml.dump(existing_data, sio)
              dumped = sio.getvalue().splitlines()

              # Find the 'repeaters:' line, then count sequence items under it.
              out_lines = []
              seq_count = 0
              in_repeaters = False
              # compute where sequence starts: locate line that is exactly 'repeaters:' (allow trailing spaces)
              for idx, line in enumerate(dumped):
                  stripped = line.rstrip()
                  if not in_repeaters and stripped == 'repeaters:':
                      in_repeaters = True
                      out_lines.append(line)
                      continue

                  if in_repeaters:
                      # match only top-level sequence items under repeaters (indentation of two spaces then hyphen)
                      # allow matches like "  - " or more indentation if mapping style differs
                      m = re.match(r'^(\s*)-\s', line.lstrip() and line if False else line)  # placeholder to satisfy logic below
                      # Instead, compute indent as leading spaces count
                      leading = len(line) - len(line.lstrip(' '))
                      if line.lstrip().startswith('- '):
                          # this is a sequence item line
                          seq_count += 1
                          # if this sequence index corresponds to a newly appended item, insert a blank line before it
                          # seq_count is 1-based; start_idx is number of old items
                          if seq_count > start_idx:
                              # only add blank line if previous output line isn't already blank
                              if len(out_lines) == 0 or out_lines[-1].strip() != '':
                                  out_lines.append('')
                          out_lines.append(line)
                          continue
                      else:
                          out_lines.append(line)
                          continue
                  else:
                      out_lines.append(line)

              # If we never found 'repeaters:' (unlikely), just fallback to dumped content
              if not in_repeaters:
                  out_text = "\n".join(dumped) + "\n"
              else:
                  out_text = "\n".join(out_lines) + "\n"

              # Write back the processed YAML
              with open(yml_path, 'w', encoding='utf-8') as fh:
                  fh.write(out_text)

              # Write GitHub Action outputs
              output_file = os.environ.get('GITHUB_OUTPUT')
              if output_file:
                  def safe(v):
                      return '' if v is None else str(v)
                  with open(output_file, 'a', encoding='utf-8') as of:
                      of.write(f"new_count={len(new_repeaters)}\n")
                      of.write(f"duplicate_count={len(duplicate_repeaters)}\n")
                      of.write(f"updated_count={len(updated_repeaters)}\n")
                      of.write(f"state_corrections_count={len(state_corrections)}\n")
                      of.write(f"last_heard_updates={last_heard_updates}\n")
                      of.write(f"power_updates={power_updates}\n")
                      of.write(f"location_updates={location_updates}\n")
                      of.write(f"has_duplicates={'true' if len(duplicate_repeaters) > 0 else 'false'}\n")
                      of.write("has_changes=true\n")

                      def esc(s):
                          return str(s).replace('|', '\\|') if s is not None else ''

                      new_table = "\n".join(
                          [f"| ğŸ†• | {esc(r.get('name'))} | `{safe(r.get('id'))}` | `{(r.get('hex_id')[:16] + '...') if r.get('hex_id') else ''}` |" for r in new_repeaters]
                      )
                      of.write(f"new_table<<EOF\n{new_table}\nEOF\n")

                      dup_table = "\n".join(
                          [f"| âš ï¸ | {esc(r.get('existing_name','Unknown'))} | {esc(r.get('name'))} | `{safe(r.get('id'))}` | `{(r.get('hex_id')[:16] + '...') if r.get('hex_id') else ''}` |" for r in duplicate_repeaters]
                      )
                      of.write(f"dup_table<<EOF\n{dup_table}\nEOF\n")

                      upd_table = "\n".join(
                          [f"| `{r['id'] or ''}` | {esc(r['old_name'])} | {esc(r['new_name'])} | `{(r['hex_id'][:16] + '...') if r.get('hex_id') else ''}` |" for r in updated_repeaters]
                      )
                      of.write(f"upd_table<<EOF\n{upd_table}\nEOF\n")

                      state_table = "\n".join(
                          [f"| {esc(r['name'])} | `{r['id']}` | `{r['old_state']}` | `{r['new_state']}` |" for r in state_corrections]
                      )
                      of.write(f"state_table<<EOF\n{state_table}\nEOF\n")

                      location_table = "\n".join(
                          [f"| {esc(r['name'])} | `{r['id']}` | `{(r['hex_id'][:16] + '...') if r.get('hex_id') else ''}` | {esc(r.get('old_location') or 'TBD')} | {esc(r.get('new_location') or 'TBD')} |" for r in location_updates_list]
                      )
                      of.write(f"location_table<<EOF\n{location_table}\nEOF\n")

          else:
              # No changes: write has_changes=false
              output_file = os.environ.get('GITHUB_OUTPUT')
              if output_file:
                  with open(output_file, 'a', encoding='utf-8') as of:
                      of.write("has_changes=false\n")
          EOF

      - name: Create Pull Request
        if: steps.sync.outputs.has_changes == 'true'
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Sync repeaters from MeshMapper API (${{ steps.sync.outputs.new_count }} new, ${{ steps.sync.outputs.power_updates }} power updates)"
          title: "ğŸ”„ Sync: ${{ steps.sync.outputs.new_count }} new, ${{ steps.sync.outputs.power_updates }} power, ${{ steps.sync.outputs.location_updates }} location"
          body: |
            ## ğŸ¤– Automated Repeater Sync

            This PR was automatically generated by syncing with the [MeshMapper API](https://yow.meshmapper.net/repeaters.json).

            ${{ steps.sync.outputs.has_duplicates == 'true' && '> **âš ï¸ WARNING:** This PR contains duplicate ID entries that require manual review before merging!' || '> âœ… **Safe to auto-merge**' }}

            ### ğŸ“Š Summary

            | Type | Count |
            |------|-------|
            | ğŸ†• New Repeaters | **${{ steps.sync.outputs.new_count }}** |
            | âš ï¸ Duplicate ID Repeaters | **${{ steps.sync.outputs.duplicate_count }}** |
            | ğŸ“ Updated Names | **${{ steps.sync.outputs.updated_count }}** |
            | ğŸ”§ State Corrections | **${{ steps.sync.outputs.state_corrections_count }}** |
            | ğŸ• Last Heard Updates | **${{ steps.sync.outputs.last_heard_updates }}** |
            | âš¡ Power Updates | **${{ steps.sync.outputs.power_updates }}** |
            | ğŸ“ Location/City Updates | **${{ steps.sync.outputs.location_updates }}** |

            ### ğŸ†• New Repeaters
            | Type | Name | ID | Hex ID |
            |------|------|----|--------|
            ${{ steps.sync.outputs.new_table }}

            ### âš ï¸ Duplicate ID Repeaters
            | Type | Existing Name | New Name | ID | Hex ID |
            |------|---------------|----------|----|--------|
            ${{ steps.sync.outputs.dup_table }}

            ### ğŸ“ Updated Names
            | ID | Old Name | New Name | Hex ID |
            |----|----------|----------|--------|
            ${{ steps.sync.outputs.upd_table }}

            ### ğŸ“ Location/City Updates
            | Name | ID | Hex ID | Old Location | New Location |
            |------|----|-------|--------------|--------------|
            ${{ steps.sync.outputs.location_table }}

            ### ğŸ”§ State Corrections
            | Name | ID | Old State | New State |
            |------|----|-----------|-----------|
            ${{ steps.sync.outputs.state_table }}

            ---
            _Generated automatically by the sync workflow._